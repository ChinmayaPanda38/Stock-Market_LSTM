# -*- coding: utf-8 -*-
"""UPD_STOCK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fq23pz94-vDwVwO1bmnpQCR527fxFvdM
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
import sklearn

start ='2012-01-01'
end='2024-11-21'
stock='MSFT'
data= yf.download(stock,start,end)

data.reset_index(inplace=True)

data

"""**TAKING THE MOVING AVARAGE OF 100 DAYS**"""

ma_100_days=data.Close.rolling(100).mean()

plt.figure(figsize=(6,6))
plt.plot(ma_100_days,'g')
plt.plot(data.Close,'b')
plt.show()

"""**TAKING THE MOVING AVARAGE OF 200 DAYS ALONG WITH 100 DAYS**"""

ma_200_days=data.Close.rolling(200).mean()

plt.figure(figsize=(6,6))
plt.plot(ma_100_days,'r')
plt.plot(ma_200_days,'g')
plt.plot(data.Close,'b')
plt.show()

"""**TAKING THE MOVING AVARAGE OF 400 DAYS**"""

ma_400_days=data.Open.rolling(400).mean()

plt.plot(ma_400_days,'b')
plt.plot(data.Open,'r')
plt.show()

"""**DROPPING THE NULL VALUES**"""

data.dropna(inplace=True)

"""**DEVIDING THE DATA IN TO TRAIN AND TEST DATA**"""

data_train= pd.DataFrame(data.Close[0: int(len(data)*0.80)])
data_test= pd.DataFrame(data.Close[ int(len(data)*0.80):len(data)])

data_train.shape[0]

data_test.shape[0]

"""**TAKING MIN MAX SCALLER FOR SCALLING THE DATA**"""

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler(feature_range=(0,1))#here fitiing the data between 1 and 0 using mean max scaler

data_train_scale=scaler.fit_transform(data_train)

x=[]
y=[]
for i in range(100,data_train_scale.shape[0]):#slicing from 1st day to 100th day for prediction of 101th day
    x.append(data_train_scale[i-100:i])
    y.append(data_train_scale[i,0])

x,y=np.array(x),np.array(y)#converting the two data two numpy arrays

"""**IMPORTING LSTM MODEL**"""

from keras.layers import Dense,Dropout,LSTM
from keras.models import Sequential

"""**LAYERING THE DATA**"""

model=Sequential()

#here total 4 LSTM layers are created
#relu : it is a nural network parametre which is passed to calculate the rnn nural network
#return_sequence:it is the rpocess of connecting one layer's output to the another layer's input
#Dropout:if we will go only in the training data set our model eill be fitted so tightly so it may not give the accurate output.
#that's why dropout is taken to drop some of the data after each training

model.add(LSTM(units=50,activation='relu',return_sequences=True,input_shape=((x.shape[1],1))))
model.add(Dropout(0.2))#here it is holding 50 nerulas
# 0.2 = 20%

model.add(LSTM(units=60,activation='relu',return_sequences=True))
model.add(Dropout(0.3))#here it is holding 60 layer and so on

model.add(LSTM(units=80,activation='relu',return_sequences=True))
model.add(Dropout(0.4))

model.add(LSTM(units=120,activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(units=1))
#as we are going to predict the closing price of the stock we need to give one output

model.compile(optimizer='adam',loss ='mean_squared_error')

"""**MODEL TRAINING**"""

model.fit(x,y,epochs=50,batch_size=32,verbose=1)

model.summary()

pas_100_days=data_train.tail(100)

data_test = pd.concat([pas_100_days,data_test],ignore_index=True)

data_test_scaler = scaler.fit_transform(data_test)

x=[]
y=[]
for i in range(100,data_test_scaler.shape[0]):
    x.append(data_test_scaler[i-100:i])
    y.append(data_test_scaler[i,0])
x,y=np.array(x),np.array(y)

y_predict=model.predict(x)

scale=1/scaler.scale_

scale=1/scaler.scale_

y_predict=y_predict*scale

y=y*scale

plt.figure(figsize=(10 ,8))
plt.plot(y_predict,'r',label='predicted_price') # Slice y_predict to get a 1D array
plt.plot(y,'g',label='original_price') # Use original y values
plt.xlabel('time')
plt.ylabel('price')
plt.legend()
plt.show()

import joblib

# Save the model
joblib.dump(model, "stock_prediction.pkl")

# Ensure MinMaxScaler is applied (rescale test data)
data_test_scaled = scaler.transform(data_test)

# Prepare test data (X_test) similar to how X_train was created
X_test = []
for i in range(100, len(data_test_scaled)):  # Use the last 100 days to predict the next day
    X_test.append(data_test_scaled[i-100:i])

# Convert list to numpy array
X_test = np.array(X_test)

# Reshape for LSTM: (samples, timesteps, features)
X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

# Ensure model is loaded if needed
import joblib
model = joblib.load("stock_prediction.pkl")  # Load model if kernel restarted

# Predict
y_pred = model.predict(X_test)

# Rescale predictions back to the original scale
y_pred = y_pred * (1 / scaler.scale_)

# Print first few predicted values
print(y_pred[-3:-1])

"""**GETTING ACCURACY MATRICS**"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Ensure 'y_pred' and 'y' exist
print(f"y_pred shape: {y_pred.shape}")
print(f"y shape: {y.shape}")

# Calculating the errors
mae = mean_absolute_error(y, y_pred)
rmse = np.sqrt(mean_squared_error(y, y_pred))
r2 = r2_score(y, y_pred)

# Print accuracy metrics
print(f"Model Performance Metrics:")
print(f"Mean Absolute Error (MAE): {mae:.4f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")
print(f"R² Score: {r2:.4f}")

# Visualize Errors
plt.figure(figsize=(8, 5))
plt.bar(["MAE", "RMSE", "R² Score"], [mae, rmse, r2], color=['blue', 'green', 'red'])
plt.title("Model Accuracy Metrics")
plt.show()

#from google.colab import files
#files.download("stock_prediction.pkl")

"""**PREDICTING FUTURE DAYS PRICE BASED ON PREVIOUS DATA**"""

import numpy as np
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from datetime import timedelta

# Assuming 'model' is defined somewhere in your code
def predict_stock_price(stock_symbol, start_date, end_date, future_days=0):
    """Predicts stock prices for a given date range and future days."""
    # Fetch stock data
    data = yf.download(stock_symbol, start=start_date, end=end_date)

    if data.empty:
        print("No data available for the given stock and date range.")
        return

    # Preprocess data
    data_train = data["Close"].values.reshape(-1, 1)

    # Scale data
    scaler = MinMaxScaler(feature_range=(0, 1))
    data_scaled = scaler.fit_transform(data_train)

    # Prepare test data
    X_test = []
    for i in range(100, len(data_scaled)):
        X_test.append(data_scaled[i-100:i])

    if not X_test:
        print("Not enough historical data for prediction.")
        return

    X_test = np.array(X_test)
    X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

    # Predict stock price for given date range
    y_pred = model.predict(X_test)

    # Reverse scaling
    y_pred = y_pred * (1 / scaler.scale_)

    # Print predicted prices
    predicted_dates = data.index[100:]  # Corresponding dates for predictions
    print("Predicted Stock Prices:")
    for date, price in zip(predicted_dates, y_pred):
        print(f"Predicted price on {date.date()}: ${price[0].item():.2f}")  # Extract scalar value

    # Predict future stock prices if future_days > 0
    if future_days > 0:
        last_100_days = data_scaled[-100:]
        future_predictions = []

        for _ in range(future_days):
            input_data = last_100_days.reshape(1, 100, 1)
            future_price = model.predict(input_data)[0][0]

            # Reverse scale
            future_price_real = future_price * (1 / scaler.scale_)
            future_predictions.append(future_price_real)

            # Update last_100_days with new prediction
            last_100_days = np.append(last_100_days[1:], future_price).reshape(100, 1)

        print("\nPredicted Future Stock Prices:")
        future_dates = [data.index[-1] + timedelta(days=i) for i in range(1, future_days + 1)]
        for date, price in zip(future_dates, future_predictions):
            print(f"Predicted price on {date.date()}: ${price.item():.2f}")  # Extract scalar value

# Get user input
stock_symbol = input("Enter Stock Symbol (e.g., MSFT): ").upper()
start_date = input("Enter Start Date (YYYY-MM-DD): ")
end_date = input("Enter End Date (YYYY-MM-DD): ")
future_days = int(input("Enter number of future days to predict: "))

# Run prediction
predict_stock_price(stock_symbol, start_date, end_date, future_days)